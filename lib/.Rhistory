contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
#make a db connection: lock the db while
con <- dbConnect(RSQLite::SQLite(),"C:/Users/daniel.woodrich/Desktop/database/lab_data.db")
dbClearResult(dbSendQuery(con, "PRAGMA foreign_keys = ON"))
dbClearResult(dbSendQuery(con, "PRAGMA busy_timeout = 60000")) #will attempt to wait for up to one minute before error
dbClearResult(dbSendQuery(con,"PRAGMA locking_mode = EXCLUSIVE"))
dbClearResult(dbSendQuery(con,"BEGIN EXCLUSIVE"))
#testing R package
res=dbSendQuery(con, "SELECT * FROM bins LIMIT 4")
dbFetch(res)
dbClearResult(res)
bins()$getkey(bins()$getschema())
dbtable <- setRefClass("dbtable",
#fields=list(), #or take data as field?
methods = list(
#probably want a method 'getkey' that will get primary key from db
getschema = function(){
tableName = .self$getClass()@className[1]
query = dbSendQuery(con,paste("PRAGMA table_info(",tableName,")",sep=""))
out = dbFetch(query)
dbClearResult(query)
return(out)
},
getkey = function(){
schema = getschema()
return(schema[which(schema$pk==1),"name"])
},
compare = function(knownkeys,data){
View(data)
if(knownkeys==TRUE){
print(.self$test1)
#query db for keys- keys that aren't found will be added, those that are will be
}else{
stop('cannot compare if db keys are not known: this should be treated as an insert operation')
}
#query table for known keys
}
)
)
soundfiles <-setRefClass("soundfiles",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins <-setRefClass("bins",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins()$getschema()
bins()$getkey()
dbtable <- setRefClass("dbtable",
#fields=list(), #or take data as field?
methods = list(
#probably want a method 'getkey' that will get primary key from db
getschema = function(){
tableName = .self$getClass()@className[1]
query = dbSendQuery(con,paste("PRAGMA table_info(",tableName,")",sep=""))
out = dbFetch(query)
dbClearResult(query)
return(out)
},
getprimkey = function(){
schema = getschema()
return(schema[which(schema$pk==1),"name"])
},
compare = function(knownkeys,data){
View(data)
if(knownkeys==TRUE){
print(.self$test1)
#query db for keys- keys that aren't found will be added, those that are will be
print(.self$getprimkey)
}else{
stop('cannot compare if db keys are not known: this should be treated as an insert operation')
}
#query table for known keys
}
)
)
soundfiles <-setRefClass("soundfiles",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins <-setRefClass("bins",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins()$testinherit(TRUE,cars)
dbtable <- setRefClass("dbtable",
#fields=list(), #or take data as field?
methods = list(
#probably want a method 'getkey' that will get primary key from db
getschema = function(){
tableName = .self$getClass()@className[1]
query = dbSendQuery(con,paste("PRAGMA table_info(",tableName,")",sep=""))
out = dbFetch(query)
dbClearResult(query)
return(out)
},
getprimkey = function(){
schema = getschema()
return(schema[which(schema$pk==1),"name"])
},
compare = function(knownkeys,data){
View(data)
if(knownkeys==TRUE){
#query db for keys- keys that aren't found will be added, those that are will be
print(.self$getprimkey)
}else{
stop('cannot compare if db keys are not known: this should be treated as an insert operation')
}
#query table for known keys
}
)
)
soundfiles <-setRefClass("soundfiles",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins <-setRefClass("bins",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins()$testinherit(TRUE,cars)
library(RSQLite)
library(DBI)
dbtable <- setRefClass("dbtable",
#fields=list(), #or take data as field?
methods = list(
#probably want a method 'getkey' that will get primary key from db
getschema = function(){
tableName = .self$getClass()@className[1]
query = dbSendQuery(con,paste("PRAGMA table_info(",tableName,")",sep=""))
out = dbFetch(query)
dbClearResult(query)
return(out)
},
getprimkey = function(){
schema = getschema()
return(schema[which(schema$pk==1),"name"])
},
compare = function(knownkeys,data){
View(data)
if(knownkeys==TRUE){
#query db for keys- keys that aren't found will be added, those that are will be
print(.self$getprimkey())
}else{
stop('cannot compare if db keys are not known: this should be treated as an insert operation')
}
#query table for known keys
}
)
)
soundfiles <-setRefClass("soundfiles",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins <-setRefClass("bins",
contains="dbtable",
methods =list(
testinherit = function(knownkeys,data){
.self$compare(knownkeys=knownkeys,data=data)
print(str(con))
print("it worked")
},
insert = function(){
#insert new rows into SFs
#generate standard bins from SFs and insert into bins and bintype
print('yes')
}
)
)
bins()$testinherit(TRUE,cars)
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, FOREIGN KEY (deployments_name) REFERENCES deployments (Name));")
dbExecute(con,".tables")
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, FOREIGN KEY (Deployments_Name) REFERENCES deployments (Name));")
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, FOREIGN KEY (deployments_name) REFERENCES deployments(Name));")
test = dbSendQuery(con, "PRAGMA foreign_keys")
dbFetch(test)
dbClearResult(test)
deployments <-setRefClass("deployments",contains="dbtable")
deployments()$getschema()
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, deployments_name TEXT FOREIGN KEY (deployments_name) REFERENCES deployments(Name)");
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, FOREIGN KEY (deployments_name) REFERENCES deployments(Name)");
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, FOREIGN KEY (deployments_name) REFERENCES deployments(Name));")
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, deployments_name TEXT, FOREIGN KEY (deployments_name) REFERENCES deployments(Name)");
dbExecute(con,"CREATE TABLE soundfiles(Name TEXT PRIMARY KEY, Duration REAL, deployments_name TEXT, FOREIGN KEY (deployments_name) REFERENCES deployments(Name));")
dbExecute(con,".tables")
dbListTables(con)
soundfiles()$getschema()
dbDisconnect(con)
datasets<-dir("./GroundTruth/GS/")
detections_add<-foreach(i=1:length(datasets)) %do% {
data<-read.csv(paste("./GroundTruth/GS/",datasets[i],sep=""))
data$FG<-substr(datasets[i],4,nchar(datasets[i])-4)
data$Deployment<-"NULL"
return(data)
}
#modify columns for database.
library(foreach)
setwd("C:/Users/daniel.woodrich/Desktop/database")
detections <- read.csv("detections.csv")
analysts_detections<-read.csv("analysts_detections.csv")
analysts<-read.csv("analysts.csv")
datasets<-dir("./GroundTruth/GS/")
detections_add<-foreach(i=1:length(datasets)) %do% {
data<-read.csv(paste("./GroundTruth/GS/",datasets[i],sep=""))
data$FG<-substr(datasets[i],4,nchar(datasets[i])-4)
data$Deployment<-"NULL"
return(data)
}
getwd()
str(detections)
datasets
detections_add<-foreach(i=1:11) %do% {
data<-read.csv(paste("./GroundTruth/GS/",datasets[i],sep=""))
data$FG<-substr(datasets[i],4,nchar(datasets[i])-4)
data$Deployment<-"NULL"
return(data)
}
detections_add<-do.call('rbind',detections_add)
detections_add$probs<-"NULL"
detections_add$VisibleHz<-"1024"
detections_add$Comments<-""
detections_add$LastAnalyst<-"DFW"
str(detections_add)
View(detections_add)
library(RSQLite)
#install.packages("RSQLite")
setwd("C:/Users/daniel.woodrich/Desktop/database/dbuddy/lib")
user.input <- function(prompt) {
if (interactive()) {
return(readline(prompt))
} else {
cat(prompt)
return(readLines("stdin", n=1))
}
}
source("classes.R")
source("dbcon.R")
suppressWarnings(suppressMessages(library(RSQLite)))
lookup_datatype<-read.csv("../etc/DataTypeLookupR_SQLite3.csv")
lookup_datatype$R_name[which(is.na(lookup_datatype$R_name))]<-"NA"
#make a db connection, and set some standard pragma settings.
con <-standard_con("C:/Users/daniel.woodrich/Desktop/database/lab_data_exp.db")
command = paste("SELECT Name FROM SoundFiles WHERE",FileName,"= $id",sep=" ")
command = paste("SELECT Name FROM SoundFiles WHERE FileName= $id",sep=" ")
test <-  dbSendStatement(con,command)
command = paste("SELECT Name FROM soundfiles WHERE Filename= $id",sep=" ")
test <-  dbSendStatement(con,command)
soundfiles()$getschema()
command = paste("SELECT deployments_name FROM soundfiles WHERE Name= $id",sep=" ")
test <-  dbSendStatement(con,command)
dbBind(test, params=list(id=detections_add$StartFile))
deps =dbFetch(test)
View(cbind(detections_add,deps))
detections_add$Deployment<-deps
command = paste("SELECT DateTime FROM soundfiles WHERE Name= $id",sep=" ")
test <-  dbSendStatement(con,command)
dbBind(test, params=list(id=detections_add$StartFile))
dt =dbFetch(test)
detections_add$datetime = dt
View(detections_add)
setwd("C:/Users/daniel.woodrich/Desktop/database")
write.csv(detections_add,"GScollectedForDana_w_metadata.csv",row.names = FALSE)
View(detections_add)
detections_add_save=detections_add
detections_add[,c("label")]<-NULL
detections_add[,c("Type","SignaCode","FG","probs")]<-NULL
write.csv(detections_add,"GScollectedForDana_w_metadata_smaller.csv",row.names = FALSE)
str(detections_add)
str(as.character(detections_add$Deployment))
str(detections_add$Deployment)
str(detections_add$Deployment[,1])
detections_add$Deployment<-detections_add$Deployment[,1]
detections_add$datetime<-detections_add$datetime[,1]
str(detections_add)
write.csv(detections_add,"GScollectedForDana_w_metadata_smaller.csv",row.names = FALSE)
#install.packages("RSQLite")
setwd("C:/Users/daniel.woodrich/Desktop/database/dbuddy/lib")
user.input <- function(prompt) {
if (interactive()) {
return(readline(prompt))
} else {
cat(prompt)
return(readLines("stdin", n=1))
}
}
source("classes.R")
source("dbcon.R")
suppressWarnings(suppressMessages(library(RSQLite)))
lookup_datatype<-read.csv("../etc/DataTypeLookupR_SQLite3.csv")
lookup_datatype$R_name[which(is.na(lookup_datatype$R_name))]<-"NA"
#make a db connection, and set some standard pragma settings.
con <-standard_con("C:/Users/daniel.woodrich/Desktop/database/lab_data_exp.db")
FG = "XB17_AM_ES01_reduce_GSex.csv"
#if .csv is present, remove it from string
if(grepl(".csv",FG)){
FG = substr(FG,1,nchar(FG)-4)
}
command = paste("SELECT FileName,SegStart,Segdur FROM bins JOIN bins_filegroups ON bins.id = bins_filegroups.bins_id JOIN filegroups ON
bins_filegroups.FG_name = filegroups.Name WHERE filegroups.Name='",FG,"';",sep="")
query = dbSendQuery(con,command)
out = dbFetch(query)
out
FG
command = paste("SELECT soundfiles.Name,soundfile.Duration,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;")
moremeta <-  dbSendStatement(con,command)
dbBind(moremeta, params=list(fnames=out$FileName))
command = paste("SELECT soundfiles.Name,soundfile.Duration,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;")
command = "SELECT soundfiles.Name,soundfile.Duration,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;"
moremeta <-  dbSendStatement(con,command)
command = "SELECT soundfiles.Name,soundfiles.Duration,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;"
moremeta <-  dbSendStatement(con,command)
dbBind(moremeta, params=list(fnames=out$FileName))
out2 = dbFetch(moremeta)
oout
out2
command = "SELECT soundfiles.Name,soundfiles.Duration,soundfiles.DateTime,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;"
moremeta <-  dbSendStatement(con,command)
dbBind(moremeta, params=list(fnames=out$FileName))
out2 = dbFetch(moremeta)
out2
data.frame(out,out2)
out
data.frame(out,out2[,2:4])
out2
format(out2$DateTime,"%y%m%d-%H%M%S")
format(out2$DateTime,"%y%m%d-%H%M%S")
format(out2$DateTime,"%y%N%d-%H%M%S")
format(out2$DateTime,"%y%M%d-%H%M%S")
format(out2$DateTime,"%y%m%d-%H%M%S")
format(out2$DateTime,"%y%m%d")
format(out2$DateTime,"%y")
str(out2$DateTime)
as.POSIXct(out2$DateTime)
out2$DateTime<-as.POSIXct(out2$DateTime,tz="UTC")
format(out2$DateTime,"%y%m%d-%H%M%S")
format(out2$DateTime,"%m")
paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%y"))
paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%y"),sep="")
paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%y"),"/",sep="")
paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%Y"),"/",sep="")
#finally, the path can get derived from DateTime and Mooring name.
#format datetime to character 6digit date and 6digit time
out = data.frame(out$FileName,paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%Y"),"/",sep=""),format(out2$DateTime,"%y%m%d-%H%M%S"),out2$Duration,out2$Name,out$SegStart,out$SegDur)
out
colnames(out)<-c("FileName","FullPath","StartTime","Duration","Deployment","SegStart","SegDur")
FG
out2
command = paste("SELECT FileName,SegStart,Segdur FROM bins JOIN bins_filegroups ON bins.id = bins_filegroups.bins_id JOIN filegroups ON
bins_filegroups.FG_name = filegroups.Name WHERE filegroups.Name='",FG,"';",sep="")
query = dbSendQuery(con,command)
out = dbFetch(query)
dbClearResult(query)
command = "SELECT soundfiles.Name,soundfiles.Duration,soundfiles.DateTime,deployments.Name FROM soundfiles JOIN deployments ON soundfiles.deployments_name = deployments.Name
WHERE soundfiles.Name=$fnames;"
moremeta <-  dbSendStatement(con,command)
dbBind(moremeta, params=list(fnames=out$FileName))
out2 = dbFetch(moremeta)
dbClearResult(moremeta)
out2$DateTime<-as.POSIXct(out2$DateTime,tz="UTC")
out2
paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%Y"),"/",sep="")
out2=out2[,2:length(out2)]
#finally, the path can get derived from DateTime and Mooring name.
#format datetime to character 6digit date and 6digit time
out = data.frame(out$FileName,paste("/",out2$Name,"/",format(out2$DateTime,"%m"),"_",format(out2$DateTime,"%Y"),"/",sep=""),format(out2$DateTime,"%y%m%d-%H%M%S"),out2$Duration,out2$Name,out$SegStart,out$SegDur)
out
colnames(out)<-c("FileName","FullPath","StartTime","Duration","Deployment","SegStart","SegDur")
out
MethodID<-"dbuddy-compare-publish-v1-0"
args="C:/Apps/INSTINCT/Cache/809545/548038/950334/563707/279418 C:/Apps/INSTINCT/Cache/809545/548038 C:/Apps/INSTINCT/Cache/809545/548038/950334/563707/279418/227655  dbuddy-compare-publish-v1-0"
args<-strsplit(args,split=" ")[[1]]
EditDataPath <-args[1]
PriorDataPath <- args[2]
resultPath <- args[3]
PriorData<-read.csv(paste(PriorDataPath,"DETx.csv.gz",sep="/"))
EditData<-read.csv(paste(EditDataPath,"DETx.csv.gz",sep="/"))
detcols<-c("id","StartTime","EndTime","LowFreq","HighFreq","StartFile","EndFile","probs","VisibleHz",
"label","Comments","SignalCode","Type","Analysis_ID","LastAnalyst")
#make sure comments which are na are instead set to blank:
PriorData$Comments[is.na(PriorData$Comments)]<-""
EditData$Comments[is.na(EditData$Comments)]<-""
#make sure dfs are in the right order
EditData<-EditData[,detcols]
PriorData<-PriorData[,detcols]
if(any(!colnames(EditData)==colnames(PriorData))){
stop("edited data columns do not match database standard")
}
#this will not necessarily put this in a logical order when there are multiple deployments, but it is at least standard as every det needs a timestamp (sort by id will fail where
#id not present)
PriorData<-PriorData[order(PriorData$StartFile,PriorData$StartTime),]
EditData<-EditData[order(EditData$StartFile,EditData$StartTime),]
#seperate the edited data into those with keys that match priordata, and keys that are novel (or missing).
mod_keys = EditData$id[which(EditData$id %in% PriorData$id)]
new_data = EditData[-which(EditData$id %in% PriorData$id),]
del_keys= PriorData$id[-which(PriorData$id %in% EditData$id)]
EditData
PriorData
View(EditData)
mod_keys
operations = as.vector(rep("",3),mode='list')
names(operations)<-c("Modify","Insert","Delete")
EditMod= EditData[which(EditData$id %in% mod_keys),]
PriorMod= PriorData[which(PriorData$id %in% mod_keys),]
if(nrow(EditMod)!=nrow(PriorMod)){
stop("ERROR: redundant IDs present in df")
}
#reduce this set to only rows which were modified
testdf = EditMod!=PriorMod
sums = rowSums(testdf,na.rm=TRUE)
EditMod = EditMod[sums>0,]
EditMod
new_data
del_keys
length(del_keys)
length(del_keys)>0
install.packages("RSQLite")
